# IntroductiontoBufferOverflows / 缓冲区溢出

**缓冲区溢出是一种内存损坏漏洞。**

## Introduction to the x86 Architecture

当线程运行时，它从程序映像或各种动态链接库(dll)中执行代码。和程序控制信息，这就是所谓的堆栈。
多个线程的执行，运行中的应用程序中的每个线程都有自己的堆栈。

堆栈内存被CPU看作是后进先出(LIFO)结构。这本质上意味着在访问堆栈时，放在堆栈顶部的项首先被删除(“弹出”)。x86体系结构实现了专用的PUSH和POP汇编指令，以便分别向堆栈添加或删除数据。

当线程中的代码调用一个函数时，它必须知道函数完成后返回哪个地址。这个“返回地址”(以及函数的参数和局部变量)存储在堆栈中。此数据集合与一个函数调用相关联，并存储在堆栈内存的一个称为堆栈帧的部分中

一些寄存器，包括EAX、EBX、ECX、EDX、ESI和EDI，通常用作存储临时数据的通用寄存器。关于这个讨论还有很多(在各种在线资源297中有解释)，但是我们的主要寄存器描述如下:

* EAX(累加器):算术和逻辑指令
* EBX(基):内存地址的基指针
* ECX(计数器):循环、移位和旋转计数器
* EDX(数据):I/O端口寻址、乘法和除法
* ESI(源索引):字符串复制操作中数据和源的指针寻址
* EDI(目标索引):字符串复制操作中数据和目标的指针寻址

**堆栈指针** 

堆栈用于存储数据、指针和参数。由于堆栈是动态的，并且在程序执行期间不断变化，ESP(堆栈指针)通过存储一个指向堆栈的指针来“跟踪”堆栈上最近引用的位置(堆栈顶部)。

指针是对内存中的地址(或位置)的引用。当我们说一个寄存器“存储一个指针”或“指向”一个地址，这本质上意味着寄存器存储目标地址。

**EBP -基本指针
由于堆栈在线程执行期间不断变化，因此函数很难找到自己的堆栈帧，该堆栈帧存储所需的参数、局部变量和返回地址。当函数被调用时，EBP通过存储一个指向堆栈顶部的指针来解决这个问题。通过访问EBP，函数可以在执行时轻松地从它自己的堆栈框架(通过偏移量)引用信息。**

**指令指针
指令指针EIP对于我们来说是最重要的寄存器之一，因为它总是指向下一个要执行的代码指令。因为EIP本质上指导程序的流程，所以当攻击者利用任何内存损坏漏洞(如缓冲区溢出)时，EIP是攻击者的主要目标。**

